<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Monochrome Mamba '97</title>
    <style>
        @font-face {
            font-family: 'Pixel';
            src: url('data:font/woff2;base64,d09GMgABAAAAAAMMAAsAAAAAB3AAAAL/AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwCYIAgqB8g/BgsGAAQgA4RMAwREBcwZyAuBCAeFVyNCkPy+5H9/0D7BDyZJ2ADk08P+z6pS1sT8/mJgh2_sQITJqNIo4KCmKMR5lC2Kud0T7eD7/t+51XEQAAfGfA0g8QLN8BGYElkMhSTp0pNHpU8tTPp5U6dkmzVlB8T//5J01Kk1RpGqOQjE2sJIOhUUhS+L5fD5fL5fL5fD5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5f-L5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL5fL...=') format('woff2');
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #f0ead6;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }
        
        #app-container {
            padding: 12px;
            background: #303d07;
            box-shadow: inset 0 0 0 4px #4a7522, inset 0 0 0 8px #3e621c;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            background-color: #a7d301;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            flex-shrink: 0;
            border: none;
        }

        #ui-container {
            font-family: 'Pixel', monospace;
            color: #f0ead6;
            background-color: #303d07;
            padding: 1vh 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .score-display {
            display: flex;
            flex-direction: column;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .icon-btn {
            width: 28px;
            height: 28px;
            cursor: pointer;
            color: #f0ead6;
        }
        .icon-btn:hover {
            color: #a7d301;
        }


        #joystick-container {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
            width: 300px;
            height: 200px;
            flex-shrink: 0;
        }

        .joy-btn {
            background-color: #5a524c;
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: pointer;
            border-top: 4px solid #7a726c;
            border-left: 4px solid #7a726c;
            border-right: 4px solid #3a322c;
            border-bottom: 4px solid #3a322c;
        }
        .joy-btn:active {
            background-color: #6a625c;
            border-top: 4px solid #3a322c;
            border-left: 4px solid #3a322c;
            border-right: 4px solid #7a726c;
            border-bottom: 4px solid #7a726c;
        }
        
        .joy-btn svg {
            width: 45px;
            height: 45px;
            fill: #f0ead6;
        }

        #joy-up { grid-area: up; }
        #joy-left { grid-area: left; }
        #joy-right { grid-area: right; }
        #joy-down { grid-area: down; }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="ui-container">
            <div class="score-display">
                <div id="score">SCORE: 0000</div>
                <div id="high-score">HI: 0000</div>
            </div>
            <div id="level">LVL: 1</div>
            <div class="controls">
                <div id="back-btn" class="icon-btn" style="display: none;"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"></path></svg></div>
                <div id="restart-btn" class="icon-btn" style="display: none;"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.76,6 15.24,6.81 16.22,8.04L13,11H20V4L17.65,6.35Z"></path></svg></div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="joystick-container">
            <div class="joy-btn" id="joy-up"><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg></div>
            <div class="joy-btn" id="joy-left"><svg viewBox="0 0 24 24"><path d="M15.41 7.41L10.83 12l4.58 4.59L14 18l-6-6 6-6z"/></svg></div>
            <div class="joy-btn" id="joy-right"><svg viewBox="0 0 24 24"><path d="M10 6l-1.41 1.41L13.17 12l-4.58 4.59L10 18l6-6z"/></svg></div>
            <div class="joy-btn" id="joy-down"><svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const levelElement = document.getElementById('level');
        const backBtn = document.getElementById('back-btn');
        const restartBtn = document.getElementById('restart-btn');
        const uiContainer = document.getElementById('ui-container');

        // --- Game Configuration ---
        let GRID_SIZE = 20;
        const GRID_COUNT = 16; 
        
        // --- Game State Variables ---
        let gameState = 'BOOTING';
        let snake, foods, direction, score, gameLoopInterval, currentSpeed, highScore;
        let directionChangedThisTick = false;
        foods = [];
        let frameCounter = 0;
        let audioCtx;
        let audioInitialized = false;
        let walls = [];
        let teleportAnimation = { active: false, originalSnake: [], newSnake: [] };

        // --- God Levels Specific Variables ---
        let currentGodLevel = 0;

        // --- God Levels Data ---
        const godLevels = [
            { name: "CLOSING IN", type: "randomWall", initialSpeed: 250, speedDecrement: 5, minSpeed: 80 },
            { name: "QUANTUM LEAP", type: "teleport", initialSpeed: 250, speedDecrement: 5, minSpeed: 80 },
            { 
                name: "THE GAUNTLET", 
                type: "maze",
                initialSpeed: 260, 
                speedDecrement: 6,
                minSpeed: 90,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,0,0,0,0,1,1,1,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,1,1,1,0,0,0,0,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ]
            }
        ];

        // --- Audio Functions ---
        function initAudio() { if (!audioInitialized && (window.AudioContext || window.webkitAudioContext)) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioInitialized = true; } catch(e) { console.error("Web Audio API not supported"); } } }
        function playStartSound() { if (!audioInitialized) return; const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g);g.connect(audioCtx.destination);o.type='square';o.frequency.setValueAtTime(220,audioCtx.currentTime);o.frequency.exponentialRampToValueAtTime(440,audioCtx.currentTime+0.2);g.gain.setValueAtTime(0.1,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.3);o.start(audioCtx.currentTime);o.stop(audioCtx.currentTime+0.3); }
        function playEatSound() { if (!audioInitialized) return; const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g);g.connect(audioCtx.destination);o.type='sine';o.frequency.setValueAtTime(523.25,audioCtx.currentTime);g.gain.setValueAtTime(0.2,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.1);o.start(audioCtx.currentTime);o.stop(audioCtx.currentTime+0.1); }
        function playGameOverSound() { if (!audioInitialized) return; const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g);g.connect(audioCtx.destination);o.type='sawtooth';o.frequency.setValueAtTime(440,audioCtx.currentTime);o.frequency.exponentialRampToValueAtTime(110,audioCtx.currentTime+0.5);g.gain.setValueAtTime(0.2,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.5);o.start(audioCtx.currentTime);o.stop(audioCtx.currentTime+0.5); }

        // --- Layout & Drawing ---
        function setupResponsiveLayout() {
            const availableHeight = window.innerHeight;
            const availableWidth = window.innerWidth;
            const appContainer = document.getElementById('app-container');
            const maxAppWidth = availableWidth * 0.95, maxAppHeight = availableHeight * 0.95;
            appContainer.style.width = `${maxAppWidth}px`; appContainer.style.height = `${maxAppHeight}px`;
            const containerRect = appContainer.getBoundingClientRect();
            const uiHeight = 40, joystickHeight = 240, gap = 15;
            const availableCanvasHeight = containerRect.height - uiHeight - joystickHeight - gap * 2 - 24;
            const availableCanvasWidth = containerRect.width - 24;
            const gridSizeFromHeight = Math.floor(availableCanvasHeight / GRID_COUNT);
            const gridSizeFromWidth = Math.floor(availableCanvasWidth / GRID_COUNT);
            GRID_SIZE = Math.max(5, Math.min(gridSizeFromHeight, gridSizeFromWidth));
            canvas.width = GRID_COUNT * GRID_SIZE; canvas.height = GRID_COUNT * GRID_SIZE;
            const totalWidth = canvas.width;
            const scaleFactor = totalWidth / 350;
            uiContainer.style.fontSize = `${Math.max(10, 16 * scaleFactor)}px`;
            if (gameState !== 'BOOTING') draw();
        }

        // --- Game Flow & State Management ---
        function bootSequence() {
            let bootText = "MONOCHROME MAMBA '97", shownText = "", charIndex = 0;
            draw();
            let interval = setInterval(() => {
                shownText += bootText[charIndex];
                drawBootMessage(shownText);
                charIndex++;
                if (charIndex >= bootText.length) {
                    clearInterval(interval);
                    setTimeout(() => { gameState = 'GOD_MENU'; draw(); }, 1000);
                }
            }, 100);
        }

        function startGodLevel(levelIndex) {
            playStartSound(); score = 0; loadGodLevel(levelIndex);
        }

        function loadGodLevel(levelIndex) {
            currentGodLevel = levelIndex;
             if (levelIndex >= godLevels.length) {
                gameState = 'GAME_OVER';
                draw();
                drawMessage("YOU ARE A GOD!", "ALL LEVELS COMPLETE");
                return;
            }
            const levelData = godLevels[currentGodLevel];
            currentSpeed = levelData.initialSpeed; walls = [];
            snake = [{ x: 2, y: 1 }]; direction = {x: 0, y: 0};
            foods = [];
            manageFood();
            gameState = 'PLAYING';
            if(gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, currentSpeed);
            updateUI();
        }
        
        function gameLoop() {
            directionChangedThisTick = false; // Reset input lock
            if (gameState !== 'PLAYING' || teleportAnimation.active) return;
            frameCounter++; update(); draw();
        }

        function update() {
            if (direction.x === 0 && direction.y === 0) return;
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            if (checkCollision(head)) {
                playGameOverSound(); gameState = 'GAME_OVER'; saveHighScore();
                clearInterval(gameLoopInterval); draw(); return;
            }

            snake.unshift(head);
            const ateFoodIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);
            const ateFood = ateFoodIndex !== -1;

            if (ateFood) {
                playEatSound(); 
                score += 10;
                if (score > highScore) {
                    highScore = score;
                }
                foods.splice(ateFoodIndex, 1);
                
                const levelData = godLevels[currentGodLevel];
                if (levelData.type === 'randomWall') {
                    spawnWall();
                } else if (levelData.type === 'teleport') {
                    initiateTeleport(); return;
                } else if (levelData.type === 'maze' && snake.length >= levelData.grid.flat().filter(c => c === 0).length) {
                        levelComplete(); return;
                }
                
                const newSpeed = Math.max(levelData.minSpeed, levelData.initialSpeed - Math.floor(score / 20) * levelData.speedDecrement);
                if (newSpeed !== currentSpeed) {
                    currentSpeed = newSpeed;
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(gameLoop, currentSpeed);
                }
                updateUI(); 
                manageFood();
            } else {
                snake.pop();
            }
        }
        
        function initiateTeleport() {
            clearInterval(gameLoopInterval);
            teleportAnimation.active = true;
            teleportAnimation.originalSnake = JSON.parse(JSON.stringify(snake));
            
            const newHeadPos = findSafeSpot();
            let safeDirections = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
            
            for (let i = safeDirections.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [safeDirections[i], safeDirections[j]] = [safeDirections[j], safeDirections[i]];
            }

            let newDirection;
            for(const d of safeDirections) {
                const checkPos = { x: newHeadPos.x + d.x, y: newHeadPos.y + d.y };
                if (!checkCollision(checkPos, true)) {
                    newDirection = d;
                    break;
                }
            }
            if (!newDirection) newDirection = {x:1, y:0}; // Fallback

            direction = newDirection;
            teleportAnimation.newSnake = [newHeadPos];
            animateTeleport();
        }

        function animateTeleport() {
            if (!teleportAnimation.active) return;

            if (teleportAnimation.originalSnake.length > 0) {
                teleportAnimation.originalSnake.shift();
            }

            if (teleportAnimation.newSnake.length < snake.length) {
                const head = teleportAnimation.newSnake[0];
                const newHead = { x: head.x + direction.x, y: head.y + direction.y };
                teleportAnimation.newSnake.unshift(newHead);
            } else {
                const head = teleportAnimation.newSnake[0];
                const newHead = { x: head.x + direction.x, y: head.y + direction.y };
                teleportAnimation.newSnake.unshift(newHead);
                teleportAnimation.newSnake.pop();
            }

            draw(); 

            if (teleportAnimation.originalSnake.length === 0 && teleportAnimation.newSnake.length === snake.length) {
                teleportAnimation.active = false;
                snake = [...teleportAnimation.newSnake];
                manageFood();
                updateUI();
                gameLoopInterval = setInterval(gameLoop, currentSpeed);
                return;
            }
            
            setTimeout(animateTeleport, currentSpeed);
        }

        function levelComplete() {
            clearInterval(gameLoopInterval);
            gameState = 'LEVEL_COMPLETE';
            currentGodLevel++;
            draw();
        }
        
        function updateUIVisibility() {
            const isPlaying = gameState === 'PLAYING';
            restartBtn.style.display = isPlaying ? 'block' : 'none';
            backBtn.style.display = isPlaying ? 'block' : 'none';
        }

        function draw() {
            ctx.fillStyle = '#a7d301';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if(gameState !== 'BOOTING' && gameState !== 'GOD_MENU') {
                 drawWalls();
            } else if (gameState === 'GOD_MENU') { 
                for (let i = 0; i < GRID_COUNT; i++) {
                    drawPixelatedRect(i * GRID_SIZE, 0);
                    drawPixelatedRect(i * GRID_SIZE, (GRID_COUNT - 1) * GRID_SIZE);
                     if (i > 0 && i < GRID_COUNT -1) {
                          drawPixelatedRect(0, i * GRID_SIZE);
                          drawPixelatedRect((GRID_COUNT - 1) * GRID_SIZE, i * GRID_SIZE);
                    }
                }
            }
            
            if (['PLAYING', 'GAME_OVER', 'LEVEL_COMPLETE'].includes(gameState) || teleportAnimation.active) {
                drawGameElements();
            }
            switch (gameState) {
                case 'GOD_MENU': drawGodMenu(); break;
                case 'GAME_OVER': drawMessage("GAME OVER", "TAP TO RESTART"); break;
                case 'LEVEL_COMPLETE': drawMessage("LEVEL COMPLETE!", "TAP FOR NEXT LEVEL"); break;
            }
            updateUIVisibility();
        }
        
        const wallPattern = [
            [0, 1, 2, 1], [1, 2, 1, 0], [2, 1, 0, 1], [1, 0, 1, 2]
        ];
        function drawPixelatedRect(x, y) {
            const PIXEL_SIZE = GRID_SIZE / 4;
            const wallColors = ['#4a7522', '#3e621c', '#303d07'];
             for (let r = 0; r < 4; r++) {
                  for (let c = 0; c < 4; c++) {
                        ctx.fillStyle = wallColors[wallPattern[r][c]];
                        ctx.fillRect( x + c * PIXEL_SIZE, y + r * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                  }
             }
        }

        function drawWalls() {
            const levelData = godLevels[currentGodLevel];
            
            if (levelData.type === 'maze') {
                const grid = levelData.grid;
                for(let r = 0; r < grid.length; r++) {
                    for(let c = 0; c < grid[r].length; c++) {
                        if(grid[r][c] === 1) drawPixelatedRect(c * GRID_SIZE, r * GRID_SIZE);
                    }
                }
            } else if (levelData.type === 'randomWall' || levelData.type === 'teleport') {
                for (let i = 0; i < GRID_COUNT; i++) {
                    drawPixelatedRect(i * GRID_SIZE, 0);
                    drawPixelatedRect(i * GRID_SIZE, (GRID_COUNT - 1) * GRID_SIZE);
                    if (i > 0 && i < GRID_COUNT -1) {
                        drawPixelatedRect(0, i * GRID_SIZE);
                        drawPixelatedRect((GRID_COUNT - 1) * GRID_SIZE, i * GRID_SIZE);
                    }
                }
                 walls.forEach(wall => drawPixelatedRect(wall.x * GRID_SIZE, wall.y * GRID_SIZE));
            }
        }
        
        function drawSnakeTube(snakeArray, dir) {
            if (!snakeArray || snakeArray.length === 0) return;
            const snakeWidth = GRID_SIZE * 0.95; 

            ctx.strokeStyle = '#31a400';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = snakeWidth;

            if (snakeArray.length > 1) {
                ctx.beginPath();
                ctx.moveTo(snakeArray[0].x * GRID_SIZE + GRID_SIZE / 2, snakeArray[0].y * GRID_SIZE + GRID_SIZE / 2);
                 for (let i = 1; i < snakeArray.length; i++) {
                      ctx.lineTo(snakeArray[i].x * GRID_SIZE + GRID_SIZE / 2, snakeArray[i].y * GRID_SIZE + GRID_SIZE / 2);
                }
                ctx.stroke();
            }
            
            const head = snakeArray[0];
            const headX = head.x * GRID_SIZE + GRID_SIZE / 2;
            const headY = head.y * GRID_SIZE + GRID_SIZE / 2;

            ctx.fillStyle = '#31a400';
            ctx.beginPath();
            ctx.arc(headX, headY, snakeWidth / 2, 0, 2 * Math.PI);
            ctx.fill();
            
            drawSnakeHead(head, dir);
        }

        function drawSnakeHead(head, dir) {
            const headX = head.x * GRID_SIZE + GRID_SIZE / 2;
            const headY = head.y * GRID_SIZE + GRID_SIZE / 2;
            const eyeSize = GRID_SIZE / 6;
            const offset = GRID_SIZE / 4;
            let eye1X, eye1Y, eye2X, eye2Y;
            if (dir.x === 1) { eye1X = headX + offset/2; eye1Y = headY - offset; eye2X = headX + offset/2; eye2Y = headY + offset; } 
            else if (dir.x === -1) { eye1X = headX - offset/2; eye1Y = headY - offset; eye2X = headX - offset/2; eye2Y = headY + offset; } 
            else if (dir.y === 1) { eye1X = headX - offset; eye1Y = headY + offset/2; eye2X = headX + offset; eye2Y = headY + offset/2; } 
            else { eye1X = headX - offset; eye1Y = headY - offset/2; eye2X = headX + offset; eye2Y = headY - offset/2; }
            
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(eye1X, eye1Y, eyeSize, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eye2X, eye2Y, eyeSize, 0, 2 * Math.PI); ctx.fill();
            
            ctx.fillStyle = 'black';
            const pupilOffset = eyeSize / 3;
            ctx.beginPath(); ctx.arc(eye1X + dir.x * pupilOffset, eye1Y + dir.y * pupilOffset, eyeSize/2, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eye2X + dir.x * pupilOffset, eye2Y + dir.y * pupilOffset, eyeSize/2, 0, 2 * Math.PI); ctx.fill();
        }

       function drawGameElements() {
            if (teleportAnimation.active) {
                drawSnakeTube(teleportAnimation.originalSnake, direction);
                drawSnakeTube(teleportAnimation.newSnake, direction);
            } else {
                drawSnakeTube(snake, direction);

                if (frameCounter % 15 < 12) {
                    foods.forEach(food => {
                        ctx.fillStyle = '#d90429';
                        ctx.beginPath();
                        ctx.arc( food.x * GRID_SIZE + GRID_SIZE / 2, food.y * GRID_SIZE + GRID_SIZE / 2, GRID_SIZE / 2.3, 0, 2 * Math.PI );
                        ctx.fill();
                    });
                }
            } 
        }
        
        function drawMessage(line1, line2) {
            ctx.fillStyle = 'rgba(15, 56, 15, 0.85)';
            ctx.textAlign = 'center';
            const fontSize1 = canvas.width / 15;
            ctx.font = `bold ${fontSize1}px 'Pixel'`;
            ctx.fillText(line1, canvas.width / 2, canvas.height / 2 - GRID_SIZE);
            if (line2) {
                const fontSize2 = canvas.width / 25;
                ctx.font = `normal ${fontSize2}px 'Pixel'`;
                ctx.fillText(line2, canvas.width / 2, canvas.height / 2 + GRID_SIZE * 1.5);
            }
        }

        function drawBootMessage(text) {
            ctx.fillStyle = '#a7d301';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawMessage(text);
        }
        
        function drawGodMenu() {
            drawMessage("CHOOSE CHALLENGE", "");
            const fontSize = canvas.width / 22;
            ctx.font = `normal ${fontSize}px 'Pixel'`;
            ctx.fillText(`1. ${godLevels[0].name}`, canvas.width / 2, canvas.height / 2 + GRID_SIZE * 2);
            ctx.fillText(`2. ${godLevels[1].name}`, canvas.width / 2, canvas.height / 2 + GRID_SIZE * 4);
            ctx.fillText(`3. ${godLevels[2].name}`, canvas.width / 2, canvas.height / 2 + GRID_SIZE * 6);
        }
        
        function findSafeSpot() {
            let safeSpot;
            while (true) {
                let onObject = false;
                const levelData = godLevels[currentGodLevel];
                if (levelData.type === 'maze') {
                     const emptyCells = [];
                      for(let r=1; r < GRID_COUNT - 1; r++) {
                          for(let c=1; c < GRID_COUNT - 1; c++) {
                                if (levelData.grid[r] && levelData.grid[r][c] === 0 && !snake.some(s => s.x === c && s.y === r)) {
                                    emptyCells.push({x: c, y: r});
                              }
                          }
                      }
                      safeSpot = emptyCells.length > 0 ? emptyCells[Math.floor(Math.random() * emptyCells.length)] : {x:1, y:1};
                } else {
                    safeSpot = { 
                        x: Math.floor(Math.random() * (GRID_COUNT - 6)) + 3, 
                        y: Math.floor(Math.random() * (GRID_COUNT - 6)) + 3
                    };
                    if (snake.some(segment => segment.x === safeSpot.x && segment.y === safeSpot.y)) onObject = true;
                    if (walls.some(wall => wall.x === safeSpot.x && wall.y === safeSpot.y)) onObject = true;
                    if (foods.some(f => f.x === safeSpot.x && f.y === safeSpot.y)) onObject = true;
                }
                if (!onObject) break;
            }
            return safeSpot;
        }

        function manageFood() {
            const targetFoodCount = snake.length > 20 ? 3 : (snake.length > 10 ? 2 : 1);
            while (foods.length < targetFoodCount) {
                foods.push(findSafeSpot());
            }
        }

        function spawnWall() {
            if (walls.length < (GRID_COUNT - 2) * (GRID_COUNT - 2) - snake.length - 5) {
                const wall = findSafeSpot(); walls.push(wall);
            }
        }

        function checkCollision(head, ignoreSelf = false) {
            const levelData = godLevels[currentGodLevel];

            if (levelData.type === 'maze') {
                if (head.x < 0 || head.x >= GRID_COUNT || head.y < 0 || head.y >= GRID_COUNT || levelData.grid[head.y][head.x] === 1) {
                    return true;
                }
            } else {
                if (head.x < 1 || head.x >= GRID_COUNT - 1 || head.y < 1 || head.y >= GRID_COUNT - 1) {
                    return true;
                }
                if (levelData.type === 'randomWall' && walls.some(wall => wall.x === head.x && wall.y === head.y)) {
                    return true;
                }
            }
            
            if (ignoreSelf) return false;

            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) return true;
            }
            return false;
        }
        
        function updateUI() {
            scoreElement.textContent = `SCORE: ${score.toString().padStart(4, '0')}`;
            highScoreElement.textContent = `HI: ${highScore.toString().padStart(4, '0')}`;
            levelElement.textContent = godLevels[currentGodLevel].name;
        }
        
        function loadHighScore() { highScore = parseInt(localStorage.getItem('mambaHighScore') || 0, 10); }
        function saveHighScore() { localStorage.setItem('mambaHighScore', highScore); }

        function handleDirectionChange(newDir) {
            if (teleportAnimation.active || directionChangedThisTick) return;

            if (direction.x === 0 && direction.y === 0) {
                if (newDir === 'up') direction = { x: 0, y: -1 };
                if (newDir === 'down') direction = { x: 0, y: 1 };
                if (newDir === 'left') direction = { x: -1, y: 0 };
                if (newDir === 'right') direction = { x: 1, y: 0 };
                if (direction.x !== 0 || direction.y !== 0) {
                     directionChangedThisTick = true;
                }
                return;
            }

            if (snake.length > 1) {
                if ((newDir === 'up' && direction.y === 1) || (newDir === 'down' && direction.y === -1) ||
                    (newDir === 'left' && direction.x === 1) || (newDir === 'right' && direction.x === -1)) {
                    return;
                }
            }

            if (newDir === 'up' && direction.y === 0) {
                direction = { x: 0, y: -1 };
                directionChangedThisTick = true;
            }
            if (newDir === 'down' && direction.y === 0) {
                direction = { x: 0, y: 1 };
                directionChangedThisTick = true;
            }
            if (newDir === 'left' && direction.x === 0) {
                direction = { x: -1, y: 0 };
                directionChangedThisTick = true;
            }
            if (newDir === 'right' && direction.x === 0) {
                direction = { x: 1, y: 0 };
                directionChangedThisTick = true;
            }
        }

        // --- Event Listeners ---
        function handleKeyPress(key) {
             initAudio();
             if (gameState === 'GOD_MENU') {
                 if (key === '1') startGodLevel(0); if (key === '2') startGodLevel(1); if (key === '3') startGodLevel(2); return;
            }
             if (gameState === 'GAME_OVER') { loadGodLevel(currentGodLevel); return; }
             if (gameState === 'LEVEL_COMPLETE') { startGodLevel(currentGodLevel); return; }
             if(gameState === 'PLAYING') {
                 switch (key) {
                    case 'ArrowUp': case 'w': handleDirectionChange('up'); break;
                    case 'ArrowDown': case 's': handleDirectionChange('down'); break;
                    case 'ArrowLeft': case 'a': handleDirectionChange('left'); break;
                    case 'ArrowRight': case 'd': handleDirectionChange('right'); break;
                }
             }
        }
        
        restartBtn.addEventListener('pointerdown', () => { if (gameState !== 'PLAYING') return; initAudio(); loadGodLevel(currentGodLevel); });
        backBtn.addEventListener('pointerdown', () => { initAudio(); clearInterval(gameLoopInterval); gameState = 'GOD_MENU'; draw(); });
        window.addEventListener('keydown', e => handleKeyPress(e.key));
        document.getElementById('joy-up').addEventListener('pointerdown', () => { initAudio(); handleDirectionChange('up'); });
        document.getElementById('joy-down').addEventListener('pointerdown', () => { initAudio(); handleDirectionChange('down'); });
        document.getElementById('joy-left').addEventListener('pointerdown', () => { initAudio(); handleDirectionChange('left'); });
        document.getElementById('joy-right').addEventListener('pointerdown', () => { initAudio(); handleDirectionChange('right'); });
        
        canvas.addEventListener('pointerdown', (e) => {
            initAudio();
            if (gameState === 'GAME_OVER') { loadGodLevel(currentGodLevel); } 
            else if (gameState === 'GOD_MENU') {
                 const rect = canvas.getBoundingClientRect();
                 const y = e.clientY - rect.top;
                 const option1Y = canvas.height / 2 + GRID_SIZE * 1, option2Y = canvas.height / 2 + GRID_SIZE * 3, option3Y = canvas.height / 2 + GRID_SIZE * 5;
                 if (y > option1Y && y < option2Y) startGodLevel(0);
                 else if (y > option2Y && y < option3Y) startGodLevel(1);
                 else if (y > option3Y) startGodLevel(2);
            }
            else if (gameState === 'LEVEL_COMPLETE') { startGodLevel(currentGodLevel); }
        });

        window.addEventListener('resize', setupResponsiveLayout);

        // --- Initial Call ---
        loadHighScore(); setupResponsiveLayout(); bootSequence();
    </script>
</body>
</html>

